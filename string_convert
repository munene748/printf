#include "main.h"

unsigned int convert_string(va_list args, buffer_t *buffer_output,
                            unsigned char format_flags,int width,
                            int precision, unsigned charlength_modifier)
unsigned int convert_string_caps(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier);
unsigned int convert_reversed(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier);
unsigned int convert_rot13(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier);


/**
 * convert_string - Converts an argument to a string and writes it into a buffer.
 * @args: Argument list pointing to the string to be written.
 * @format_flags: Formatting flags for the conversion.
 * @width: The width for the formatted output.
 * @precision: Precision for the conversion.
 * @length_modifier: Length modifier for the conversion (e.g., short, long).
 * @buffer_output: Struct containing a buffer to store the string.
 *
 * Return: The number of bytes written into the buffer.
 */
unsigned int convert_string(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier)
{
char *input_string, *null_string = "(null)";
	int string_length;
	unsigned int bytes_written = 0;

	(void)format_flags;
	(void)length_modifier;

	input_string = va_arg(arg, char *);
	if (input_string == NULL)
		return (_memcpy(buffer_output, null_string, 6));

	for (string_length = 0; *(input_string + string_length);)
		string_length++;

	bytes_written += print_string_width(buffer_output, format_flags,
	width, precision, string_length);

	precision = (precision == -1) ? string_length : precision;
	while (*input_string != '\0' && precision > 0)
	{
		bytes_written += _memcpy(buffer_output, input_string, 1);
		precision--;
		input_string++;
	}

	bytes_written += print_neg_width(buffer_output, bytes_written,
	format_flags, width);

	return (bytes_written);
}

/**
 * convert_string_caps - Converts an argument to a string with special characters
 *                       encoded and writes it into a buffer.
 * @args: Argument list pointing to the string to be written.
 * @format_flags: Formatting flags for the conversion.
 * @width: The width for the formatted output.
 * @precision: Precision for the conversion.
 * @length_modifier: Length modifier for the conversion (e.g., short, long).
 * @buffer_output: Struct containing a buffer to store the string.
 *
 * Return: The number of bytes written into the buffer.
 *
 * Description: ASCII values < 32 or >= 127[Non-printables]
 * are stored as \x followed by the ASCII code value in hex.
 */
unsigned int convert_string_caps(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier)
{
	char *input_string, *null_string = "(null)", *hex_format =
	"\\x", zero_char = '0';
	int string_length, char_index;
	unsigned int bytes_written = 0;

	(void)length_modifier;

	input_string = va_arg(args, char *);
	if (input_string == NULL)
		return (_memcpy(buffer_output, null_string, 6));

	for (string_length = 0; input_string[string_length];)
		string_length++;

	bytes_written += print_string_width(buffer_output, format_flags,
	width, precision, string_length);

	precision = (precision == -1) ? string_length : precision;
	for (char_index = 0; *(input_string + char_index) != '\0'
	&& char_index < precision; char_index++)
	{
		if (*(input_string + char_index) < 32 ||
		*(input_string + char_index) >= 127)
		{
			bytes_written += _memcpy(buffer_output, hex_format, 2);
			if (*(input_string + char_index) < 16)
				bytes_written += _memcpy(buffer_output, &zero_char, 1);
			bytes_written += convert_ubase(buffer_output,
			*(input_string + char_index),
					     "0123456789ABCDEF", format_flags, 0, 0);
			continue;
		}
		bytes_written += _memcpy(buffer_output,
		(input_string + char_index), 1);
	}
bytes_written += print_neg_width(buffer_output,
	bytes_written, format_flags, width);

	return (bytes_written);
}

/**
 * reverse_string - Reverses a string and writes it into a buffer.
 * @args: Argument list pointing to the string to be reversed.
 * @format_flags: Formatting flags for the conversion.
 * @width: The width for the formatted output.
 * @precision: Precision for the conversion.
 * @length_modifier: Length modifier for the conversion (e.g., short, long).
 * @buffer_output: Struct containing a buffer to store the reversed string.
 *
 * Return: The number of bytes written into the buffer.
 */
unsigned int reverse_string(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier)
{
	char *input_string, *null_string = "(null)";
	int string_length, end_position, index;
	unsigned int bytes_written = 0;

	(void)format_flags;
	(void)length_modifier;

	input_string = va_arg(args, char *);
	if (input_string == NULL)
		return (_memcpy(buffer_output, null_string, 6));

	for (string_length = 0; *(input_string + string_length);)
		string_length++;

	bytes_written += print_string_width(buffer_output, format_flags,
	width, precision, string_length);

	end_position = string_length - 1;
	precision = (precision == -1) ? string_length : precision;
	for (index = 0; end_position >= 0 && index < precision; index++)
	{
		bytes_written += _memcpy(buffer_output, (input_string + end_position), 1);
		end_position--;
	}

	bytes_written += print_neg_width(buffer_output, bytes_written,
	format_flags, width);

	return (bytes_written);
}

/**
 * rot13_conversion - Converts a string to ROT13 encoding and writes it into a buffer.
 * @args: Argument list pointing to the string to be encoded.
 * @format_flags: Formatting flags for the conversion.
 * @width: The width for the formatted output.
 * @precision: Precision for the conversion.
 * @length_modifier: Length modifier for the conversion (e.g., short, long).
 * @buffer_output: Struct containing a buffer to store the encoded string.
 *
 * Return: The number of bytes written into the buffer.
 */
unsigned int rot13_conversion(va_list args, buffer_t *buffer_output,
		unsigned char format_flags, int width, int precision,
		unsigned char length_modifier)
{
	char *alpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	char *rot13 = "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM";
	char *input_string, *null_string = "(null)";
	int n, j, string_length;
	unsigned int bytes_written = 0;

	(void)format_flags;
	(void)length_modifier;

	input_string = va_arg(args, char *);
	if (input_string == NULL)
		return (_memcpy(buffer_output, null_string, 6));

	for (string_length = 0; *(input_string + string_length);)
		string_length++;

	bytes_written += print_string_width(buffer_output,
	format_flags, width, precision, string_length);

	precision = (precision == -1) ? string_length : precision;
	for (n = 0; *(input_string + n) != '\0' && n < precision; n++)
	{
		for (j = 0; j < 52; j++)
		{
			if (*(input_string + n) == *(alpha + j))
			{
				bytes_written += _memcpy(buffer_output, (rot13 + j), 1);
				break;
			}
		}
		if (j == 52)
			bytes_written += _memcpy(buffer_output, (input_string + n), 1);
	}

	bytes_written += print_neg_width(buffer_output, bytes_written,
	format_flags, width);

	return (bytes_written);
}
